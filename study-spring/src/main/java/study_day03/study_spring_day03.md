## Spring_Day03

今天主要是学习了Spring的AOP

### 简述

AOP(Aspect Oriented Programming)是spring中除了IOC的另一大重要思想,AOP的意思是面向切面编程

AOP主要是通过预编译方式和运行期间动态代理实现程序功能的维护,使用AOP可以对业务逻辑的各个部分进行隔离,从而使得业务逻辑各部分之间的耦合度降低,提高程序的可重用性,提高开发效率

* 优点

  **每个关注点现在都集中于一处，而不是分散到多处代码中** 
  **服务模块更简洁，服务模块只需关注核心代码。**

### 专业名词介绍

##### 通知

> * 定义:
>
>   切面也需要完成工作,在AOP术语中,**切面的工作被称为通知**
>
> * 工作内容:
>
>   通知定义了切面是什么以及何时使用.出了描述切面要完成的工作,通知还解决何时执行这个工作.
>
> * 通知的类型
>
>   spring切面可应用的5种通知类型
>
>   1. Before-----在方法调用之前调用通知
>   2. After-------在方法完成之后调用通知,无论方是否执行成功(类似于finally)
>   3. After-returning----在方法执行成功之后调用通知
>   4. After-throwing----在方法抛出异常后进行通知
>   5. Around----通知包裹了被通知的方法,在被通知的方法调用之前和调用之后执行自定义的行为

##### 切点

> * 定义:
>
>   如果通知定义了"`什么`"和"`何时`",那么切点就定义在了"`何处`",切点会匹配通知所要织入的一个或者多个连接点
>
> * 通常使用明确的类或者方法来指定这些切点
>
> * 定义通知被应用的位置(有哪些连接点)

##### 切面

> * 定义:
>
>   切面是通知和切点的集合,通知和切点共同定义了切面的全部功能--它是什么,在何时何处完成其功能

##### 连接点

> * 定义:
>
>   连接点是一个应用执行过程中能插入一个切面的点
>
> * 连接点可以是调用方法时,抛出异常时,甚至修改字段时(那么这个怎么连接?)
>
> * 切面代码可以利用这些点插入到应用的正常流程中
>
> * 程序执行过程中能够应用通知的所有点

##### 引入

> * 引入允许我们向现有的类中添加方法或属性

##### 织入

> * 织入是将切面应用到目标对象来创建的代理对象过程
> * 切面在指定的连接点呗织入到目标对象中国,在目标对象的声明周期中有多个点可以织入

##### 其他

> 1. 编期期
>
>    切面在目标类编译时期被织入,这种方式需要特殊编译器,AspectJ的织入编译器就是以这种方式织入切面
>
> 2. 类加载期
>
>    切面在类加载到`JVM`时,这种方式需要特殊的类加载器,它可以在目标类被引用应用之前增强该目标类的字节码.AspectJ5的LTW就支持这种织入方式
>
> 3. 运行期
>
>    切面在应用运行期间的某个时刻被织入,一般情况下,在织入切面的时候,AOP容器会为目标对象动态的创建代理对象,Spring AOP就是以这种方式织入切面

### Spring对于AOP的支持

* 并不是所有的AOP框架都是一样的,他们在连接点模型上可能有强弱之分
  * 有些允许对字段修饰符级别应用通知
  * 有些支持方法调用连接点

* Spring提供4种各具特色的AOP支持

  > 1. 基于代理的经典AOP
  > 2. @AspectJ注解驱动的切面
  > 3. 纯POJO切面
  > 4. 注入式AspectJ切面

* 在运行期间通知对象

  * 通过在代理类中织入包裹切面,Spring在运行期间将切面织入到Spring管理的Bean中,代理类封装了目标类,并拦截被通知的方法调用,再将调用转发给真正的目标Bean

    ![016050512341315](image/20160505123413155.jpg)

    当拦截到方法调用时,在调用目标Bean方法之前,代码会执行切面逻辑

    当真正应用需要被代理的Bean时,Spring才创建此对象,如果使用ApplicationContext,在ApplicationContext从BeanFactory中加载所有Bean时,Spring创建代理对象,因为Spring在运行时候创建代理对象,所以我们不需要特殊的编译器来织入SpringAOP的切面

* Spring支持方法创建连接点,**但是也有以下缺点**

  * 因为Spring基于动态代理,所以Spring只支持方法连接点
  * Spring缺失对字段连接点的支持,无法让我们更加细粒度的通知,例如拦截对象字段的修改
  * Spring缺失对构造器连接点支持,无法在Bean 创建时候进行通知


#### 使用切点选择连接点

* 切点用于准确定位,确定在什么地方应用切面通知

* Spring定义切点

  * 在SpringAOP中,需要使用AspectJ的切点表达式来定义切点

  | AspectJ指示器 | 描述                                                         |
  | ------------- | ------------------------------------------------------------ |
  | arg()         | 限制连接点的指定参数为指定类型的执行方法                     |
  | @args()       | 限制连接点匹配参数由指定注解标注的执行方法                   |
  | execution()   | 用于匹配连接点的执行方法                                     |
  | this()        | 限制连接点匹配AOP代理的Bean引用为指定类型的类                |
  | target()      | 限制连接点匹配特定的执行对象,这些对象对应的要具备指定类型注解 |
  | within()      | 限制连接点匹配指定类型                                       |
  | @within()     | 限制连接点匹配指定注释所标注的类型(方法定义在由指定的注解所标注的类里) |
  | @annotation   | 现在匹配带有指定注释的连接点                                 |

1.创建自己的切点

![016050512500274](image/20160505125002742.jpg)

-execution()指示器选择Instrument的play()方法

方法表达式以`*`开头,标识了我们不关心的方法返回值的类型

`*`后我们指定了全限定类名和方法名

对于方法的参数列表,使用`(..)`标识切点选择任意的play方法,无论入参是什么

-假设我们需要匹配切点仅匹配`comSpringinaction.springidol`包,可以使用within()

![016050512525744](image/20160505125257446.jpg)

注意`&&`是将execution()和within()连接起来,形成and关系,听力也可以使用||或关系,!非关系

-创建Spring的bean()指示器

Spring2.5之后引入了一个新的bean()指示器,该指示器允许我们在切点表达式中使用Bean ID来标识Bean

bean()使用Bean ID或Bean名称作为参数来限制切点只匹配特定 的Bean  ---->那么可以在bean中使用通配符吗?

如下,我们希望之星Instrument的play()方法时候应用通知,但限定Bean的ID为eddie

![016050512541623](image/20160505125416233.jpg)

还可以使用非操作作为除了指定ID的Bean以外的Bean应用通知

![016050512543110](image/20160505125431108.jpg)

在此场景下,切面会通知被编织到所有ID不为eddie的Bean 中

### 使用

#### 基于XML的配置

##### 配置文件

```xml
<!-- 配置Spring的AOP -->
<aop:config>
    <!-- 配置一个切面,这个切面表示需要在其他代码中被执行的代码 -->
    <aop:aspect id="myAspect" ref="logAdvice">
        <!--使用引用切点的方式配置一个前置通知-->
        <aop:before method="beforeMethod" pointcut-ref="anyPoint"/>
        <!-- 配置一个切点,切点表示将会和切面连接的点
       		这里配置的表达式是表示service.impl中的任意方法都会被拦截
       -->
        <aop:pointcut expression="execution(* study_day03.service.impl.*.*(..))" id="anyPoint"/>
    </aop:aspect>
</aop:config>
```

##### 切面配置

切面的配置相对比较简单,以下是一个简单的切面配置

```java
public class LogAdvice{
    public void printLog(){
        System.out.println("已经打印日志");
    }
}
```

上述的切面配置的方式可以使用于大多数的切面,但是不能环绕通知的配置方式不同,我们将会在注解模式中介绍环绕通知的配置方式

#### 基于注解的配置

##### 配置文件

如果是想要开启spring的AOP注解配置,则只要在配置文件中加入这一行即可

`<aop:aspectj-autoproxy/>`

##### 切面配置

注解配置切面相对比较麻烦,步骤如下

```java
@Component//必须要是一个bean
@Aspect//这个注解声明了这个bean将会是一个切面
public class LogAdvice{
	@Before("myPointCut")//声明前置通知并且使用myPointCut切点
    public void beforeLog(){
        System.out.println("这个是前置通知");
    }
    
    //配置一个切点
    /**
    *	表示这个切点的拦截规则,并且这个切点的名字将会是myPointCut
    */
    @PointCut("execution(* cn.willhoo.service.impl.*.*(..))")
    public void myPointCut(){}
    
    
    //配置一个环绕通知
    @Around("myPointCut")
    public void aroundAdvice(ProceedingJoinPoint pjp){
        System.out.println("这个是环绕通知1");
        System.out.println("这个是环绕通知2");

        //在这里执行目标方法
        pjp.proceed();
        //先获取这个目标的参数列表
        Object[] args = pjp.getArgs();
        System.out.println(args.length);
        
        System.out.println("这个是环绕通知3");
        System.out.println("这个是环绕通知4");
    }
}
```

* 环绕通知

  环绕通知可以在其中获得原方法的引用(不应该啊?应该其他的也是可以的),具体做法是在方法参数中添加一个参数ProceedingJoingPoint,然后通过调用proceed方法可以执行这个方法,通过getArgs方法可以获取这个方法中已经注入的参数

#### AOP注解

Spring中和AOP相关的注解如下

|   注解   |                             描述                             |
| :------: | :----------------------------------------------------------: |
|  Aspect  |          表示这个bean中的关于AOP的注解成为有效状态           |
| Before等 |              声明这个方法是前置通知,后置通知等               |
| PointCut | 将一个方法声明成为一个切点,这个方法不需要有方法体,但是PointCut需要指定切点表达式,并且方法的名字就是这个切点的名字 |

